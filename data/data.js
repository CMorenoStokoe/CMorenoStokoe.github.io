/* 

Database
---------------

Intended purpose of this script:
- This file contains the data model on which the simulation is based

Contents of this script:
- Data classes 
    A Pseudo data class is parent to child classes and provides them with basic data structure and operations 

*/


// Pseudo data class containing network MR data
class DataClass {

    constructor(nodes, edges) {

        // Index nodes and edges by id for searchability in pseudo database
        this.nodes = this.toIndex(nodes, 'id');
        this.edges = this.toIndex(edges, 'id');

    }

    // Index dictionary arrays (items) by key (key) to be searchable {item.id : item}
    toIndex(items, key, desiredProperty=null){
        var indexed = {}

        for (const item of items){

            /* TEMPORARY : Move to MiRANA: csv to json operation */
            // Make sure node and edge ID strings are safe for use as index keys (e.g., in js numbers are not safe keys since edges[0] returns the first edge whereas edges[e0] correctly returns edge e0)
            if (typeof item[key] == 'string'){
                item[key] = safeStr(item[key]);
            } else {
                let source = safeStr(item.source);
                let target = safeStr(item.target);
                item[key] = [source,target];
                item.source = source
                item.target = target
            } //temp key cleaning
            function safeStr(str){
                return str.replace(/-/g, '_')
            }

            // If a desiredProperty is given then give {key : desired property}
            // This is used if only one property is desired (e.g., an index of ids : names)
            if(desiredProperty){indexed[item[key]] = item[desiredProperty];}

            // Else give {key : item}
            else{indexed[item[key]] = item;}
            
        };

        return indexed;
    }

    // Export data as list of nodes and edges required by iterating methods and propagation MR
    // The list of nodes and edges are not given as a static resource because they change and need to be dynamically generated by function
    toList(items){
        // Make list of edges and nodes from indexed dictionary
        const list = [];
        for (const [ key, value ] of Object.entries(items)) {
            list.push(value)
        }

        return list;
    }

    // Function to change values by list of dictionaries containing key:new value
    updateNodes(update){
        
        // Iterate over list of dictionaries given as update
        for (const value in update) {
            this.nodes[value.id].prevalence=value.prevalence;
        }
    }

    // Export data as D3 node-edge dictionary
    toD3(){
        return {nodes : this.toList(this.nodes), edges : this.toList(this.edges)};
    }

    // Export data as jsnx ebunch format 
    toJsnx(){
        
        // Operate on iterable list
        const edgeList = this.toList(this.edges);
        
        // Convert edges in edgeList into jsnx ebunch format
        const ebunch = []
        for (const edge of edgeList){
            
            // Compile edge bunch for jsnx graphing ([source, target])
            ebunch.push([edge.source, edge.target]);
        }
        
        // Since jsnx populates nodes automatically from edges, nodes do not need to be specified to make a jsnx graph G object
        // Nodes should be specified if their properties need to be modelled in the graph (e.g., node prevalences if propagation was integrated into the jsnx model)
        return(ebunch);
    }

    // Export data as list of data required for propagation MR
    toPropMRData(path){
        const MRData = [];

        // Create list of data requires for propagation MR
        for (const edge of path){

            // Get source and target node IDs from current edge in path
            const sourceNodeId = edge[0]; // edge originates from this node
            const targetNodeId = edge[1]; // node to change with propagation
            
            // Construct edge id from edge source and target nodes
            const edgeId = [sourceNodeId,targetNodeId]

            // Create MRData bundle for propagation and updating resulting node prevalences
            MRData.push({
                xID : sourceNodeId, // source node id to identify where the change in this edge originated
                yID : targetNodeId, // target node id to identify which nodes are being changed through propagation 
                y0 : this.nodes[targetNodeId].prevalence, // initial prevalence of target of edge (successor node)
                b : this.edges[edgeId].b, // edge beta weight
            })
        }

        // Path of edges to propagate through with MR data
        return MRData;
    }

}

// Class for variables used only by the game
class GameData extends DataClass {

    constructor(nodes, edges) {
        // Get nodes and edges from parent class
        super(nodes, edges);
        // Make game variables
        this.objective = this.setObjective();
        this.log = [];
    }

    setObjective(){
        return (this.nodes.ieu_a_1187);
    }

    addLogEntry(entry){
        this.log.push(entry);
    }

}